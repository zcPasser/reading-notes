# 第5章：函数

## 5.1：函数定义与使用

- 函数嵌套定义

- 可调用对象
- 修饰器
  - 修饰器本质是函数，接收其他函数作为参数并对其进行一定的改造之后返回新函数。
- 函数递归调用

## 5.2：函数参数

- 形参、实参
  - 参数为列表、字典、集合或其他自定义的可变序列，且在函数内部使用下标或序列自身支持的方式为可变序列增删改操作时，结果是可以反映到函数之外的，即实参也得到了相应修改。
  - python采用基于值的自动内存管理，存储值的引用。故python中调用函数时，实参到形参都是传递的引用，即python函数不存在传值调用。

- 位置参数
  - 形参和实参顺序一致、数量相同。
  
- 默认值参数
  - 任何一个默认值参数右边不能再出现没有默认值的普通位置参数。
  - 多次调用函数且不为默认值参数传递值时，默认值参数只在定义时进行一次解释和初始化。
  - 一般来说，要避免使用列表、字典、集合或其他可变序列作为函数参数默认值。
    - 默认值参数为列表改写

  ```python
  def fun(newitem, old_list = None):
      if old_list is None:
         old_list = []
      old_list.append(newitem)
      return old_list
  ```

  - 定义函数时某参数的默认值为另一个变量的值，则参数默认值只依赖于函数定义时该变量的值，即函数的默认值参数是在函数定义时确定值的，所以只会被初始化1次。

- 关键参数

  - 主要指调用函数时的参数传递方式，与函数定义无关。
  - 直接指定参数名进行传递，实参顺序可以和形参顺序不一致。

- 可变长度参数

  - 该参数在**定义函数时**2种形式
    - *parameter
      - 用来接收任意多个实参并将其放在一个元组中。
    - **parameter
      - 接收类似于关键参数一样显示赋值形式的多个实参并将其放入字典中。

- 传递参数时序列解包

  - 与可变长度的参数相反，**该序列解包是指实参**，同样也有*和**2种形式。
    - 含有多个位置参数的函数，调用时可以使用列表、元组、集合、字典或其他可迭代对象作为实参，并且在实参名称前加一个*号，python解释器自动解包，后将序列中的值分别传递给多个单变量形参
  - 实参为字典
    - 对字典变量名加1个*解包，是对其键进行解包；对值则为 * dict.values。
    - **，则是将字典转换成类似于关键参数的形式进行参数传递。
      - 要求字典中键名和函数形参名相同，或 与函数中2个星号的可变长度参数相对应。

- 多种形式参数

  - 定义时一般将位置参数放在最前面，然后是默认值参数，接下来是1个星号的可变长度参数，最后是2个星号的可变长度参数。
  - 调用时，也按照上述顺序进行参数传递，若对实参使用1个星号进行序列解包，则解包后的实参将作为普通位置参数对待，且会在关键参数和使用2个星号进行序列解包的参数之前进行处理。

## 5.3：变量作用域

- 函数内部定义的局部变量
- 函数内部使用global定义的全局变量当函数结束后仍然存在并且可以访问。
  - 变量在函数外定义，若在函数内需要修改该变量值，且将修改结果反映到函数外，可以在函数内用关键字global明确声明要使用已定义的同名全局变量。
  - 函数内部直接使用关键字将1个变量声明为全局变量，若在函数外没有定义该全局变量，在调用函数之后，会创建新的全局变量。
- 若在某个作用域内有为变量赋值的操作，则该变量将被认为是该作用域内的局部变量。
- 若能局部变量和全局变量具有相同的名字，则该局部变量会在自己的作用域内暂时隐藏同名的全局变量。

## 5.4：lambda表达式

- 声明匿名函数。
  - 即无函数名的临时使用的小函数。
- 计算结果相当于函数的返回值。
- 使用
  - 一些类似sort的key的参数。
  - 直接给表达式起名，如f = lambda ...

## 5.5 ：生成器函数设计

- 包含yield的语句的函数可以用来创建生成器对象，也称为生成器函数。
- 每次执行到yield语句并返回一个值之后会暂停或挂起后面代码的执行，下次通过生成器对象的next方法之类显示索要数据时恢复执行。
- 生成器具有惰性求值特点，适合大数据处理。