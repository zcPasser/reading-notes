[TOC]

# 方法总结

## 字符串

大数值转为字符串处理。

## 序列

先排序。

## 双指针

- 快慢指针

  前后关系，如链表等。

- 左右端指针

  left、right
  
  使用双指针，左指针指向当前已经**处理好的序列的尾部**，右指针指向**待处理序列的头部**。

## 哈希法

借用哈希表、集合。

- 用途

  去重。

空间复杂度：O(n)。

## 位运算

注意：二进制表示，如`1`、`0`的**数量**、**位置**。

负数、取反操作

### 颠倒

可以用分组互换。——分治。

### 异或

- 规则

  - 任何数和 0 做异或运算，结果仍然是原来的数，即 a ⊕  0 =*a* ⊕ 0=*a*。
  - 任何数和其自身做异或运算，结果是 0，即 a*⊕* a=0。
  - 遵守结合律、交换律。

- 使用

  可用来找数值中相同、不同。

### 总结

#### 基本原理

0s 表示一串 0，1s 表示一串 1。

```
x ^ 0s = x      x & 0s = 0      x | 0s = x
x ^ 1s = ~x     x & 1s = x      x | 1s = 1s
x ^ x = 0       x & x = x       x | x = x
```

利用 x ^ 1s = ~x 的特点，可以将一个数的**位级表示翻转**；

利用 x ^ x = 0 的特点，可以将**三个数中重复的两个数去除，只留下另一个数**。

1^1^2 = 2
利用 **x & 0s = 0 和 x & 1s = x** 的特点，可以**实现掩码操作**。

一个数 num 与 mask：00111100 进行**位与操作**，只保留 num 中与 mask 的 1 部分相对应的位。

```
01011011 &

00111100
--------

00011000
```


利用 **x | 0s = x 和 x | 1s = 1s** 的特点，可以实现**设值操作**。

一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。

```
01011011 |

00111100
--------

01111111
```

#### 位与运算技巧

n&(n-1) **去除 n 的位级表示中最低的那一位 1**。

例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。

```
01011011 &

01011010
--------

01011010
```


n&(-n) 得到 **n 的位级表示中最低的那一位 1**。-n 得到 n 的反码加 1，也就是 **-n=~n+1**。

例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。

```
10110100 &

01001100
--------

00000100
```


n-(n&(-n)) 则可以**去除 n 的位级表示中最低的那一位 1**，和 n&(n-1) 效果一样。

#### 移位运算

**\>\> n 为算术右移**，相当于**除以 2n**，例如 -7 \>\> 2 = -2。

**高位补符号位**。

```
11111111111111111111111111111001  >> 2
--------

11111111111111111111111111111110
```

**\>\>\> n 为无符号右移**，**左边会补上 0**。例如 -7 \>\>\> 2 = 1073741822。

**高位补0**。

```
11111111111111111111111111111001  >>> 2
--------

00111111111111111111111111111111
```

**<< n 为算术左移**，相当于**乘以 2n**。-7 << 2 = -28。

```
11111111111111111111111111111001  << 2
--------

11111111111111111111111111100100
```


#### mask 计算

要获取 111111111，将 0 取反即可，**~0**。

要得到只有**第 i 位为 1 的 mask**，将 **1 向左移动 i-1 位**即可，**1<<(i-1)** 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。

要得到 **1 到 i 位为 1 的 mask**，**(1<<i)-1** 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。

要得到 **1 到 i 位为 0 的 mask**，只需将 **1 到 i 位为 1 的 mask 取反**，即 **~((1<<i)-1)**。

#### Java 中的位操作

```java
static int Integer.bitCount();           // 统计 1 的数量
static int Integer.highestOneBit();      // 获得最高位
static String toBinaryString(int i);     // 转换为二进制表示的字符串
```

## 加减乘除法

+、-、*、/

## 二叉树的3种遍历

- 前序遍历

  ```
  访问根节点-根节点入栈-访问左子树-回到根节点-根节点出栈-访问右子树。
  ```

- 后序遍历

  ```python
      # 用于记录上一次访问的节点，和前序遍历不同，其栈中上一个节点并非上一次访问的。
      prev = None
      # 后序遍历：左子树-右子树-根。
      # 实现步骤：根节点入栈-访问左子树-返回根节点-访问右子树-返回根节点-访问根节点-根节点出栈。
      """
      其中访问节点的类型：
      1、当前经过节点是叶子节点。
      2、当前经过节点的右子节点是上一次访问的节点。
      由于后序遍历的特点，栈顶节点并非上一次访问的节点，需要借助一个`prev`变量记录上一次访问的节点。
      """
  ```

- 中序遍历

# 记录

## 题171-算法

python中不存在'A' - 'A'，要借助内置函数`ord`。

## 题175-MySQL

## 题195-shell

​		给定一个文本文件 `file.txt`，请只打印这个文件中的第十行。

​		sed 可依照脚本的指令来处理、编辑文本文件。

```shell
sed -n '10p' file.txt

-n或--quiet或--silent 仅显示script处理后的结果。//即显示处理的部分。

动作说明：

a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！

```



## 题202-算法

​		有重复问题，可以用哈希，采用集合、字典。

## 题203-算法

​		1、递归。

​		2、迭代。

​		单链表删除，使用双指针`last`、`p`，或者 `p = p.next.next`。

​		注意`表头删除`，可以认为插入一个临时节点，即`dump.next = head `。
$$
创建哑节点 \textit{dummyHead}，令 \textit{dummyHead}.
\textit{next} = \textit{head}，\\初始化 \textit{temp}=\textit{dummyHead}，\\然后遍历链表进行删除操作。\\最终返回 \textit{dummyHead}.\textit{next} 即为删除操作后的头节点。
$$

## 题205-算法

​		1、映射关系——哈希处理。

## 题206-算法

​		1、反转，即创建新链表，有`头插入`、`尾插入`等创建方式，此处可用头插入方式进行创建。剩下的就是断链等操作。

## 题217-算法

​		1、去重，哈希，逐个比较是否存在 或者 set 看长度。

​		2、排序，看是否邻位相同。

## 题219-算法

​		1、哈希，重复值问题。

​		2、滑动窗口，维护一个大小=k的窗口，可利用哈希结构，python中`set`数据结构，大小判断可以结合`enumerate`，超过K时，将当前i-k-1的元素删除窗口。

## 题225-算法

​		1、用2个队列模拟栈，其实1个队列就行。

​		在入栈时，即入队时，添加，然后将之前的元素全部出队，再次入队，则新元素为栈顶。

## 题226-算法

​		1、翻转二叉树

​		每个子树当前根节点交换其左右子树。可以从第一层开始或从最后一层开始（这种要返回根节点）。

## 题228-算法

​		1、数组问题，涉及区间、窗口，可以考虑双指针如`start、end`或`构造数据结构`空间换时间。

## 题231-算法

​		1、2的幂，且为**正整数**时，结合其2进制表示，**而2进制表示只有1个1**，位运算，可以对**最低位的1操作**，**去除**则数变为0，获得也行。

## 题232-算法

​		1、2个栈模拟队列，分为输入栈和输出栈，关键是和队头元素有关操作时，从输出栈取值，若输出栈为空，则将当前输入栈元素全部逆序到输出栈中。

## 题234-算法

​		1、单链表回文判断，**其值范围=[0，9]**，遍历同时转为字符串存储，转为字符串回文判断。

​		2、值复制到数组，用双指针判断。

## 题235-算法

- 描述

  - BST找p、q的最近公共祖先（BST中无重复节点值）。
- 关键：BST特点。
- 法1

  - 从p和q入手，2次遍历BST，分别找到各自路径，然后比较。
- 法2

  - 从祖先入手，一次遍历BST，对结果进行分类，p、q在当前祖先左右子树、左子树、右子树，不断迭代当前祖先。

## 题237-算法


  - 描述

  ```
  请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。
  
  题目数据保证需要删除的节点 不是末尾节点 。
  
  链表中节点的数目范围是 [2, 1000]
  -1000 <= Node.val <= 1000
  链表中每个节点的值都是 唯一 的
  需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点
  ```


    - 关键-删除链表节点p
    
      - 通常法
        - 一：last.next = p.next。
        - 二：p.val修改值。
    
    - 本题解法
    
      结合两种解法。
    
    - 趣点
    
    **这道题细思极恐：如何让自己在世界上消失，但又不死？ —— 将自己完全变成另一个人，再杀了那个人就行了。**

## 题242-算法

```python
"""
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若s 和 t中每个字符出现的次数都相同，则称s 和 t互为字母异位词。

提示:
1、1 <= s.length, t.length <= 5 * 104
2、s 和 t仅包含小写字母

进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

思路：
法一：按照 定义 表层含义，统计字符串中各字符的次数，再比较。
法二：字母异位词 的2个字符串 按照 字典排序后，完全相同。

"""
```



## 题257-算法

```python
"""
1、描述：
给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

2、提示：
2.1、树中节点的数目在范围 [1, 100] 内
2.2、-100 <= Node.val <= 100

3、思路
3.1、DFS
当前节点 是叶子节点，则 加入路径；不是 则 继续 遍历。
非递归：用到指针last。
3.2、BFS
类似 2的次幂。
"""
```



## 题258-算法

```python
"""
1、描述
给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。

2、进阶
你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？

3、思路
3.1、模拟
1、借助循环 或 递归。
2、或 借助 字符串。

3.2、数学
除了传统的单纯循环，还可以找规律。假如一个三位数'abc'，其值大小为s1 = 100 * a + 10 * b + 1 * c，经过一次各位相加后，变为s2 = a + b + c，减小的差值为(s1 -s2) = 99 * a + 9 * b，差值可以被9整除，每一个循环都这样，缩小了9的倍数。
当num小于9，即只有一位时，直接返回num，
当大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。


X = 100*a + 10*b + c = 99*a + 9*b + (a+b+c)；所以对9取余即可。
"""
```

```
数学
1、在数学中，数根(又称位数根或数字根Digital root)是自然数的一种性质，换句话说，每个自然数都有一个数根。

2、数根是将一正整数的各个位数相加（即横向相加），若加完后的值大于10的话，则继续将各位数进行横向相加直到其值小于十为止[1]，或是，将一数字重复做数字和，直到其值小于十为止，则所得的值为该数的数根。

例如54817的数根为7，因为5+4+8+1+7=25，25大于10则再加一次，2+5=7，7小于十，则7为54817的数根。

3、
3.1、数根可以计算模运算的同余，对于非常大的数字的情况下可以节省很多时间。

3.2、数字根可作为一种检验计算正确性的方法。例如，两数字的和的数根等于两数字分别的数根的和。

3.3、另外，数根也可以用来判断数字的整除性，如果数根能被3或9整除，则原来的数也能被3或9整除。


原数:0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
数根:0 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3 

可以发现数根 9 个为一组， 1 - 9 循环出现。我们需要做就是把原数映射到树根就可以，循环出现的话，想到的就是取余了。

结合上边的规律，对于给定的 n 有三种情况。

n 是 0 ，数根就是 0。

n 不是 9 的倍数，数根就是 n 对 9 取余，即 n mod 9。

n 是 9 的倍数，数根就是 9。

我们可以把两种情况统一起来，我们将给定的数字减 1，相当于原数整体向左偏移了 1，然后再将得到的数字对 9 取余，最后将得到的结果加 1 即可。

原数是 n，树根就可以表示成 (n-1) mod 9 + 1，可以结合下边的过程理解。


原数: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
偏移: 0 1 2 3 4 5 6 7 8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 
取余: 0 1 2 3 4 5 6 7 8  0  1  2  3  4  5  6  7  8  0  1  2  3  4  5  6  7  8  0  1  2  
数根: 1 2 3 4 5 6 7 8 9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3 


```

## 题268-算法

```python
"""
1、描述
给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

2、提示：
- n == nums.length
- 1 <= n <= 10^4
- 0 <= nums[i] <= n
- nums 中的所有数字都 独一无二

3、进阶
你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

4、思路
4.1、排序
将 nums升序排序，然后 依次比较 元素值 和 其下标 是否相等。

4.2、哈希
利用成员测试运算符in、set的查找特性。
将 nums 转为 set。

4.3、位运算
利用 异或运算，同0异1.
a 异或 0 = a，a 异或 a = 0，常用来寻找 相同不同。
 n 个数，在这 n 个数的后面添加从 0 到 n 的每个整数，则添加了 n+1 个整数，共有 2n+1 个整数。
 由于上述 2n+12n+1 个整数中，丢失的数字出现了一次，其余的数字都出现了两次

4.4、数学
nums 和 range(n + 1) 分别求和，做差 得到 目标。


"""
```

## 题278-算法

```python
"""
1、描述
你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。
由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用bool isBadVersion(version)接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。
你应该尽量减少对调用 API 的次数。

2、思路
二分查找。
"""
```

## 题283-算法

```python
"""
1、描述
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。

2、提示:
. 1 <= nums.length <= 104
. -231 <= nums[i] <= 231 - 1
 
3、进阶
你能尽量减少完成的操作次数吗？

4、思路
双指针。
本质上：使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。

右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：
左指针左边均为非零数；
右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

"""
```



## 题704-算法

​		1、二分查找，求`mid`，注意溢出，如下：		

```python
mid = (high - low) // 2 + low
```

